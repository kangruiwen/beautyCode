对synchronized与volatile的一些介绍说明：

1.先介绍一些基本概念
	1.1  可见性：一个线程对一个共享变量值的修改，能够及时的被其他线程看到
	1.2  共享变量：如果一个变量在多个线程的工作内存中都存在副本，name这个变量就是这几个线程的共享变量
	
	1.3  工作能存、主内存
		为了能够更好的理解工作内存与主内存，先做如下的说明：
		1.3.1 Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量(Variable)与java编程中所说的变量略有不同，
		它包括实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为后者是线程私有的，不会被共享，自然就不存在竞争问题。为了获得较好的执行效能，java内存模型并没有
		限制执行引擎使用特定的寄存器或缓存来和主内存交互，也没有限制即时编译器调整代码执行顺序这类权利。
		1.3.2 每条线程还有自己的工作内存(Working Memory, 对应于处理器的cache), 线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，
		而不能直接读写主内中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成，线程、主内存、工作内存的交互关系如下图所示：
		
		            线程1                                       线程2                                          线程3
		     |                |                 |
		  ____________________________________________   
		 | 工作内存1|        |工作内存2|          |工作内存3 |
		  ————————————————————————————————————————————
		                |            |
		 ______________________________________________
		 |                   主内存                                                                |
		 ——————————————————————————————————————————————
		
		有两条规定：
		1：一个线程不能直接访问另一个线程的工作内存
		2：每条线程都有自己的工作内存，工作内存中保存的是主存中某些变量的拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。
	1.4  重排序
		在我们编写程序并运行的时候，编译器给我们一个错觉：程序编译的顺序与编写的顺序是一致的。但是实际上，为了提高性能，编译器和处理器常常会对指令进行重排序。
		重排序主要为一下三个：编译器优化的重排序、指令级别并行的重排序和内存系统的重排序。所以我们编写好Java源代码之后，会经过以上三个重排序，到最终的指令序列
	1.5 as-if-serial 语句
		指的是不管怎么重排序，单线程程序的执行结果不能发生改变

2.Java内存模型(Java Memory Model,JMM)






